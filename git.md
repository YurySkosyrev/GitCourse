## Команды конфигурации ##

**git config user.name** - установка имени пользователя

**git config user.email** - установка email

Настройки (config) :
- **--system** - общесистемные настройки
- **--global** - настройки на уровне пользователя
- **--local (default)** - настройки на уровне проекта

имя и email лучше задавать в глобальных настройках, тогда они будут сразу подхватываться
при создании нового проекта

**git config --list** - список настроек из всех config (local, system, global)

**git config --unset user.name** - удалить user.name

**git config --global --core.editor путь к текстовому редактору** - 
установка тектового редактора 

**git config alias.c 'config --global'** - создает alias для команды в ковычках

**git help config** - помощь по команде config

## Создание репозитория ##
**git init** - инициализация репозитория, создание папки .git

**git status** - взгляд на текущее состояние со стороны git

изменения в фаилах сначала фиксируются в Index, а затем сохраняются в Repository.

**git add имя файла** - добавление файла в index, git отслеживает изменения в этом файле.

**git commit** - сохранение файлов из Index в Repository, к информации добавляется имя пользователя, который внёс изменения. Так же необходимо ввести текст - пояснения к изменениям. Первая строка обычно является заголовком, поэтому она короткая (не более 50 символов). Используются знаки *, -, списки.

При сохранении изменений появится сообщение:<br>
create mode 100644 <br>
100 - обозначает файл<br>
644 - неисполнимый<br>
755 - исполнимый

В ОС Windows право на чтение обычно объединено с правом на выполнение, а в Unix подобных системах эти права разделены<br> 
Git проверяет, если файловая система не поддерживает отдельное право на выполнение, то ставится настройка в config <br>
**git congig core.fileMode false**<br>

Файлы, сохраняемые под Windows будут всегда без исполнимого бита в режиме 644.<br>
Если же нужно создать проект, который будет использоваться в Unix-подобных системах и файл нужно сделать исполняемым, то либо репозиторий разворачивается в Unix-подобной системе, либо вводится команда:<br>
**git update-index --chmod=+x index.html** - поставить исполнимый бит файлу напрямую в обход файловой системы, в которой он игнорируется.

Git не видит пустые директории, можно создать файл .geetkeep чтобы сделать директорию непустой.

**git add .** - добавить все изменения в index.

**git reset HEAD .folder** - убрать из index папку folder.

В файле .gitignore можно указать все файлы и папки, которые не должны попасть в index.

**git add -f(--force) .folder/file.txr** - принудительное добавление файла в индекс даже если он находится в директории, прописанной в .gitignore.

Важно, чтобы commit содержал в себе какое-то небольшое изменение - атомарность. Не нужно делать много изменений в одном коммите.

Index и двухступенчатая система сохранения решает задачу: в проекте было изменено несколько файлов, которые можно объединить в группы по смысловой нагрузке и сделать commit, соблюдая при этом павило атомарности. 

**git add -p file.txt** - позволяет в рамках одного файла выбрать его части которые были изменены для добавления в Index.

**git commit -a(--all)** - добавить изменения в файл в Index и сразу сделать commit, но это не касается файлов, которые не отслеживаются, они добавлены в Index не будут.

**git commit \<path>** - так же создает commit для файла, которые есть в Index.

**git --global alias.commitall '!git add -A; git commit'** - если после add стоит . то добавится только текущая директория, если флаг -A, то вообще все новые папки.

Если файл был удалён, то из индекса он удаляется командой **git add fileName**

**git rm \<paths>** - удалить один или несколько файлов из Index.

**git rm -r src = rm -r src + git add .** - удалить директорию из Index.

**git rm -r --cashed src** - удалить директорию из Index.

**--cashed** - флаг означает, что операции производятся с Index, а не с рабочей директорией.

Если удаляемый файл не сохранён в репозитории, то его удаление **git rm** приведет к ошибке, так как изменения не возможно будет восстановить.

**-f (--force)** - флаг принудительного выполнения операции, несмотря на запрет git.

При переименовании файла в рабочей директории, после команды **git add .** git по контрольной сумме понимает, что произошло переименование файла, а не его удаление и создание нового.

**git mv** - переименовать файл и добавить его в индекс.

## Работа с ветками ##

**Cherry-pick** - применение коммита ко всем веткам.

Ветка - ссылка на коммит.

**git branch** - информация о ветках.

**git branch -v** - показывает коммит, на который указывает ветка.

HEAD хранит ссылку на текущую ветку.

**git branch branchName** - создание новой ветки (ссылки на коммит)

**git checkout branchName** - переключиться на ветку

**git checkout -b branchName = branch + checkout**

Если мы хотим переключиться на другую ветку при незаконченных изменениях (status not clean), то git запретит это. <br>
Однако, если обе версии файла будут одинаковые, то переключение возможно и появится сообщение M - modify<br>
Возможны два варианта:

1. **git checkout -f branchName** - при этом все незакоммиченные изменения удалятся.<br>
**git checkout -f HEAD** - отменить все незакомиченные изменения на текущей ветке.
2. **git stash** - удалить все незакомиченные изменения и в специальном виде заархивировать в git.<br>
**git stash pop** - получить изменения из архива.

Если при работе на одной ветке нужно все незакомиченные изменения перенести на новую ветку, то достаточно создать новую ветку и на ней сделать **git add -am "Commit text"**, при этом старая ветка будет указывать на последний коммит, до вненсения изменений.

Допустим изменениия ошибочно закомичены на **master**, а они должны быть закомичены на ветке **fix**:
1. **git branch fix** - создаём новую ветку **fix** для коммитов.
2. **git branch -f idCommit master** - создается ветка, указывающая на коммит idCommit, так как ветка **master** существует и задан флаг -f, то git принудительно переводит её обратно на нужный коммит. При этом сначала нужно переключиться с ветки **master**. То есть происходит откат назад по ветке **master**, где были ошибочно добавлены коммиты, а ветка **fix** указывает на ошибочные коммиты.

Обратно перейти на коммит можно так же с помощью команды<br>
**git branch -f master fix** - можно передавать не только id коммита, но и название ветки, которая так же указывает на какой-то коммит.

Ещё вариант:<br> **git checkout -B master idCommmit = git branch -f idCommit master + git checkout master**

## Отделённый HEAD ##

**git checkout ifCommit** - переход на любой коммит, если переходим на коммит, на который не указывает ветка, то возникает особое состояние - detached HEAD.<br>
Если в нём делать коммиты, то будет отброшена безымянная ветка, при переключении с которой, обратно можно вернуться только по имени коммита на ней. Со временем git удаляет такие недостижимые коммиты.<br>
Перенести коммиты на существующую ветку можно с помощью команды cherry-pick

## Восстановление предыдущих версий файлов ##

**git checkout commit(branch) <paths>** - восстанавливает файл на состояние коммита и помещает его в index.

**git checkout HEAD <paths>** - восстановливает файл в состояние последнего коммита.

**git checkout <paths>** - восстановливает файл в состояние из index.

**git checkout -- master** - добавление -- показывает git, что нужно искать в первую очередь путь по названию master, а не ветку как это происходит по умолчанию.

## Просмотр истории и старых файлов, символы ~, ^, @, поиск с :/ ##

**git log** - отображение информации о всех коммитах.

**git log --oneline** - отображение информации о всех коммитах в более компактном виде.

**git log master --oneline** - отображение информации о коммитах ветки **master**.

**git show commit(branch)** - информация о коммите commit(о коммите на который указывает ветка), по умолчанию о коммите, на который указывает HEAD.

**git show HEAD~** - информация о родителе коммита на который указывает HEAD, можно применить к коммиту, к ветке.

**git show HEAD~~~ == git show ~3** - смещаемся на 3 коммита вниз по дереву.

Вместо HEAD можно писать @

**git show master~~:index.txt** - посмотреть версию файла index.txt в коммите который на 2 шага ниже коммита, на который указывает ветка master.

**git show :/function** - покажет самый свежий коммит в котором есть файл, содержащий слово function.

## Слияние веток перемоткой ##

**git merge branch** - слияние текущей ветки с веткой branch.

Метод слияния при этом Fast-Forward, то есть текущая ветка начинает ссылаться на тот же коммит, что и ветка branch.

Перед merge git сохраняет старый идентификатор в файл .git/ORIG_HEAD

Если нам нужно отменить результат последнего слияния, то можно ввести команду:<br>
**git branch -f master ORIG_HEAD**

## Удаление веток ##

**git branch -d fix** - удалить ветку fix, работает только если удаляемая ветка полностью совмещена с текущей, при этом коммиты остаются, удаляется ссылка fix.

**git branch -D fix** - удалит ветку несовмещенную с текущей, при этом удалится ссылка на коммит, коммиты удалённой ветки будут недостижимыми. Через некоторое время git удалит недостижимые коммиты.

## История переключений веток: лог ссылок reflog

Любые изменения при работе с ссылками git записывает в специальный файл reflog, файлы находятся в директории **.git/logs/**

**git reflog** - отображение логов в красивом виде.

**git branch feature HEAD@6** - создать ветку **feature** с ссылкой на коммит в 6 строке reflog для HEAD/

**git reflog show == git log --oneline -g**

**git reflog --date=iso** - добавление даты коммита к отображению файла reflog.

По умолчанию записи в reflog хранятся 90 дней, а недостижимые коммиты 30 дней.

gc.reflogExpire = "90 days ago"<br>
gc.reflogExpireUnreachable = "30 days ago"

reflog не отправляются вместе с коммитами при push или пересылке коллеге.

**git checkout @{-n}** - перейти на ветку n checkout-ов назад.

## Удаление "лишних" файлов и незакоммиченных изменений

**git reset --hard, git checkout -f** не будут отменять изменения в неотслеживаемых файлах.

**git clean -dxf** - -d удалить не только неотслеживаемые файлы, но и директории, -x - удалить и файлы, которые есть в .gitignore, -f - без этого не будет работать.

## Жесткий reset --hard: отмена изменений, удаление коммитов

**git reset --hard @~** - отмена последнего коммита.

Если в файлах были незакоммиченные изменения, они будут потеряны при reset.

## Мягкий reset --soft: замена и объединение коммитов

**git reset --soft @~** - перемещает HEAD на указанный коммит, при этом файлы в рабочей директории в и index не изменяются. Поэтому появятся незакомиченные изменения в этих файлах, так как их состояние не будет соответствовать коммиту на который сделан reset --soft.

То есть reset --soft по сути отменяет последний коммит, но оставляет все изменения в файлах.

**git reset --soft ORIG_HEAD** - id последнего коммита, на котором стоял HEAD хранится в файле ORIG_HEAD - переходим обратно, на удалённый коммит.

**git commit -c idCommit** - взять описание из описания коммита idCommit.<br>
* -c - откроется редактор, для редактирования сообщения
* -С - без редактирования

при этом копируется авторская дата и автор коммита.

** -- reset author** - сбросить автора из копируемого описания коммита.

## Правка последнего коммита: commit --amend

Вносим исправления в файл, который был закоммичен.

**git commit --amend == git reset --soft @~ + git commit -c ORIG_HEAD**

так же можно использовать флаг ** -- reset author** и **--no-edit** - отменяет вызов редактора.

**git commit ammend** можно использовать для редактирования текста коммита. Так как и сам коммит и его описание в git неизменяемы.

Однако ни **reset --soft**, ни **git commit --amend** не смогут изменить коммит в середине ветки, этими командами можно менять последний коммит. Если нужно поменять коммит в середине, то нужно переписать всю ветку, либо использовать команду rebase.










