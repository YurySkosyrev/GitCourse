## Команды конфигурации ##

**git config user.name** - установка имени пользователя

**git config user.email** - установка email

Настройки (config) :
- **--system** - общесистемные настройки
- **--global** - настройки на уровне пользователя
- **--local (default)** - настройки на уровне проекта

имя и email лучше задавать в глобальных настройках, тогда они будут сразу подхватываться
при создании нового проекта

**git config --list** - список настроек из всех config (local, system, global)

**git config --unset user.name** - удалить user.name

**git config --global --core.editor путь к текстовому редактору** - 
установка тектового редактора 

**git config alias.c 'config --global'** - создает alias для команды в ковычках

**git help config** - помощь по команде config

## Создание репозитория ##
**git init** - инициализация репозитория, создание папки .git

**git status** - взгляд на текущее состояние со стороны git

изменения в фаилах сначала фиксируются в Index, а затем сохраняются в Repository.

**git add имя файла** - добавление файла в index, git отслеживает изменения в этом файле.

**git commit** - сохранение файлов из Index в Repository, к информации добавляется имя пользователя, который внёс изменения. Так же необходимо ввести текст - пояснения к изменениям. Первая строка обычно является заголовком, поэтому она короткая (не более 50 символов). Используются знаки *, -, списки.

При сохранении изменений появится сообщение:<br>
create mode 100644 <br>
100 - обозначает файл<br>
644 - неисполнимый<br>
755 - исполнимый

В ОС Windows право на чтение обычно объединено с правом на выполнение, а в Unix подобных системах эти права разделены<br> 
Git проверяет, если файловая система не поддерживает отдельное право на выполнение, то ставится настройка в config <br>
**git congig core.fileMode false**<br>

Файлы, сохраняемые под Windows будут всегда без исполнимого бита в режиме 644.<br>
Если же нужно создать проект, который будет использоваться в Unix-подобных системах и файл нужно сделать исполняемым, то либо репозиторий разворачивается в Unix-подобной системе, либо вводится команда:<br>
**git update-index --chmod=+x index.html** - поставить исполнимый бит файлу напрямую в обход файловой системы, в которой он игнорируется.

Git не видит пустые директории, можно создать файл .geetkeep чтобы сделать директорию непустой.

**git add .** - добавить все изменения в index.

**git reset HEAD .folder** - убрать из index папку folder.

В файле .gitignore можно указать все файлы и папки, которые не должны попасть в index.

**git add -f(--force) .folder/file.txr** - принудительное добавление файла в индекс даже если он находится в директории, прописанной в .gitignore.

Важно, чтобы commit содержал в себе какое-то небольшое изменение - атомарность. Не нужно делать много изменений в одном коммите.

Index и двухступенчатая система сохранения решает задачу: в проекте было изменено несколько файлов, которые можно объединить в группы по смысловой нагрузке и сделать commit, соблюдая при этом павило атомарности. 

**git add -p file.txt** - позволяет в рамках одного файла выбрать его части которые были изменены для добавления в Index.

**git commit -a(--all)** - добавить изменения в файл в Index и сразу сделать commit, но это не касается файлов, которые не отслеживаются, они добавлены в Index не будут.

**git commit \<path>** - так же создает commit для файла, которые есть в Index.

**git --global alias.commitall '!git add -A; git commit'** - если после add стоит . то добавится только текущая директория, если флаг -A, то вообще все новые папки.

Если файл был удалён, то из индекса он удаляется командой **git add fileName**

**git rm \<paths>** - удалить один или несколько файлов из Index.

**git rm -r src = rm -r src + git add .** - удалить директорию из Index.

**git rm -r --cashed src** - удалить директорию из Index.

**--cashed** - флаг означает, что операции производятся с Index, а не с рабочей директорией.

Если удаляемый файл не сохранён в репозитории, то его удаление **git rm** приведет к ошибке, так как изменения не возможно будет восстановить.

**-f (--force)** - флаг принудительного выполнения операции, несмотря на запрет git.

При переименовании файла в рабочей директории, после команды **git add .** git по контрольной сумме понимает, что произошло переименование файла, а не его удаление и создание нового.

**git mv** - переименовать файл и добавить его в индекс.

## Работа с ветками ##

**Cherry peek** - применение коммита ко всем веткам.

Ветка - ссылка на коммит.

**git branch** - информация о ветках.

**git branch -v** - показывает коммит, на который указывает ветка.

HEAD хранит ссылку на текущую ветку.

**git branch branchName** - создание новой ветки (ссылки на коммит)

**git checkout branchName** - переключиться на ветку

**git checkout -b branchName = branch + checkout**

Если мы хотим переключиться на другую ветку при незаконченных изменениях (status not clean), то git запретит это. <br>
Однако, если обе версии файла будут одинаковые, то переключение возможно и появится сообщение M - modify<br>
Возможны два варианта:

1. **git checkout -f branchName** - при этом все незакоммиченные изменения удалятся.<br>
**git checkout -f HEAD** - отменить все незакомиченные изменения на текущей ветке.
2. **git stash** - удалить все незакомиченные изменения и в специальном виде заархивировать в git.<br>
**git stash pop** - получить изменения из архива.

Если при работе на одной ветке нужно все незакомиченные изменения перенести на новую ветку, то достаточно создать новую ветку и на ней сделать **git add -am "Commit text"**, при этом старая ветка будет указывать на последний коммит, до вненсения изменений.

Допустим изменениия ошибочно закомичены на **master**, а они должны быть закомичены на ветке **fix**:
1. **git branch fix** - создаём новую ветку **fix** для коммитов.
2. **git branch -f idCommit master** - создается ветка, указывающая на коммит idCommit, так как ветка **master** существует и задан флаг -f, то git принудительно переводит её обратно на нужный коммит. При этом сначала нужно переключиться с ветки **master**. То есть происходит откат назад по ветке **master**, где были ошибочно добавлены коммиты, а ветка **fix** указывает на ошибочные коммиты.

Обратно перейти на коммит можно так же с помощью команды<br>
**git branch -f master fix** - можно передавать не только id коммита, но и название ветки, которая так же указывает на какой-то коммит.

Ещё вариант:<br> **git checkout -B master idCommmit = git branch -f idCommit master + git checkout master**





