## Команды конфигурации ##

**git config user.name** - установка имени пользователя

**git config user.email** - установка email

Настройки (config) :
- **--system** - общесистемные настройки
- **--global** - настройки на уровне пользователя
- **--local (default)** - настройки на уровне проекта

имя и email лучше задавать в глобальных настройках, тогда они будут сразу подхватываться
при создании нового проекта

**git config --list** - список настроек из всех config (local, system, global)

**git config --unset user.name** - удалить user.name

**git config --global --core.editor путь к текстовому редактору** - 
установка тектового редактора 

**git config alias.c 'config --global'** - создает alias для команды в ковычках

**git help config** - помощь по команде config

## Создание репозитория ##
**git init** - инициализация репозитория, создание папки .git

**git status** - взгляд на текущее состояние со стороны git

изменения в фаилах сначала фиксируются в Index, а затем сохраняются в Repository.

**git add имя файла** - добавление файла в index, git отслеживает изменения в этом файле.

**git commit** - сохранение файлов из Index в Repository, к информации добавляется имя пользователя, который внёс изменения. Так же необходимо ввести текст - пояснения к изменениям. Первая строка обычно является заголовком, поэтому она короткая (не более 50 символов). Используются знаки *, -, списки.

При сохранении изменений появится сообщение:<br>
create mode 100644 <br>
100 - обозначает файл<br>
644 - неисполнимый<br>
755 - исполнимый

В ОС Windows право на чтение обычно объединено с правом на выполнение, а в Unix подобных системах эти права разделены<br> 
Git проверяет, если файловая система не поддерживает отдельное право на выполнение, то ставится настройка в config <br>
**git congig core.fileMode false**<br>

Файлы, сохраняемые под Windows будут всегда без исполнимого бита в режиме 644.<br>
Если же нужно создать проект, который будет использоваться в Unix-подобных системах и файл нужно сделать исполняемым, то либо репозиторий разворачивается в Unix-подобной системе, либо вводится команда:<br>
**git update-index --chmod=+x index.html** - поставить исполнимый бит файлу напрямую в обход файловой системы, в которой он игнорируется.

Git не видит пустые директории, можно создать файл .geetkeep чтобы сделать директорию непустой.

**git add .** - добавить все изменения в index.

**git reset HEAD .folder** - убрать из index папку folder.

В файле .gitignore можно указать все файлы и папки, которые не должны попасть в index.

**git add -f(--force) .folder/file.txr** - принудительное добавление файла в индекс даже если он находится в директории, прописанной в .gitignore.

Важно, чтобы commit содержал в себе какое-то небольшое изменение - атомарность. Не нужно делать много изменений в одном коммите.

Index и двухступенчатая система сохранения решает задачу: в проекте было изменено несколько файлов, которые можно объединить в группы по смысловой нагрузке и сделать commit, соблюдая при этом павило атомарности. 

**git add -p file.txt** - позволяет в рамках одного файла выбрать его части которые были изменены для добавления в Index.

**git commit -a(--all)** - добавить изменения в файл в Index и сразу сделать commit, но это не касается файлов, которые не отслеживаются, они добавлены в Index не будут.

**git commit \<path>** - так же создает commit для файла, которые есть в Index.

**git --global alias.commitall '!git add -A; git commit'** - если после add стоит . то добавится только текущая директория, если флаг -A, то вообще все новые папки.

Если файл был удалён, то из индекса он удаляется командой **git add fileName**

**git rm \<paths>** - удалить один или несколько файлов из Index.

**git rm -r src = rm -r src + git add .** - удалить директорию из Index.

**git rm -r --cashed src** - удалить директорию из Index.

**--cashed** - флаг означает, что операции производятся с Index, а не с рабочей директорией.

Если удаляемый файл не сохранён в репозитории, то его удаление **git rm** приведет к ошибке, так как изменения не возможно будет восстановить.

**-f (--force)** - флаг принудительного выполнения операции, несмотря на запрет git.

При переименовании файла в рабочей директории, после команды **git add .** git по контрольной сумме понимает, что произошло переименование файла, а не его удаление и создание нового.

**git mv** - переименовать файл и добавить его в индекс.

## Работа с ветками ##

**Cherry-pick** - применение коммита ко всем веткам.

Ветка - ссылка на коммит.

**git branch** - информация о ветках.

**git branch -v** - показывает коммит, на который указывает ветка.

HEAD хранит ссылку на текущую ветку.

**git branch branchName** - создание новой ветки (ссылки на коммит)

**git checkout branchName** - переключиться на ветку

**git checkout -b branchName = branch + checkout**

Если мы хотим переключиться на другую ветку при незаконченных изменениях (status not clean), то git запретит это. <br>
Однако, если обе версии файла будут одинаковые, то переключение возможно и появится сообщение M - modify<br>
Возможны два варианта:

1. **git checkout -f branchName** - при этом все незакоммиченные изменения удалятся.<br>
**git checkout -f HEAD** - отменить все незакомиченные изменения на текущей ветке.
2. **git stash** - удалить все незакомиченные изменения и в специальном виде заархивировать в git.<br>
**git stash pop** - получить изменения из архива.

Если при работе на одной ветке нужно все незакомиченные изменения перенести на новую ветку, то достаточно создать новую ветку и на ней сделать **git add -am "Commit text"**, при этом старая ветка будет указывать на последний коммит, до вненсения изменений.

Допустим изменениия ошибочно закомичены на **master**, а они должны быть закомичены на ветке **fix**:
1. **git branch fix** - создаём новую ветку **fix** для коммитов.
2. **git branch -f idCommit master** - создается ветка, указывающая на коммит idCommit, так как ветка **master** существует и задан флаг -f, то git принудительно переводит её обратно на нужный коммит. При этом сначала нужно переключиться с ветки **master**. То есть происходит откат назад по ветке **master**, где были ошибочно добавлены коммиты, а ветка **fix** указывает на ошибочные коммиты.

Обратно перейти на коммит можно так же с помощью команды<br>
**git branch -f master fix** - можно передавать не только id коммита, но и название ветки, которая так же указывает на какой-то коммит.

Ещё вариант:<br> **git checkout -B master idCommmit = git branch -f idCommit master + git checkout master**

## Отделённый HEAD ##

**git checkout ifCommit** - переход на любой коммит, если переходим на коммит, на который не указывает ветка, то возникает особое состояние - detached HEAD.<br>
Если в нём делать коммиты, то будет отброшена безымянная ветка, при переключении с которой, обратно можно вернуться только по имени коммита на ней. Со временем git удаляет такие недостижимые коммиты.<br>
Перенести коммиты на существующую ветку можно с помощью команды cherry-pick

## Восстановление предыдущих версий файлов ##

**git checkout commit(branch) <paths>** - восстанавливает файл на состояние коммита и помещает его в index.

**git checkout HEAD <paths>** - восстановливает файл в состояние последнего коммита.

**git checkout <paths>** - восстановливает файл в состояние из index.

**git checkout -- master** - добавление -- показывает git, что нужно искать в первую очередь путь по названию master, а не ветку как это происходит по умолчанию.

## Просмотр истории и старых файлов, символы ~, ^, @, поиск с :/ ##

**git log** - отображение информации о всех коммитах.

**git log --oneline** - отображение информации о всех коммитах в более компактном виде.

**git log master --oneline** - отображение информации о коммитах ветки **master**.

**git show commit(branch)** - информация о коммите commit(о коммите на который указывает ветка), по умолчанию о коммите, на который указывает HEAD.

**git show HEAD~** - информация о родителе коммита на который указывает HEAD, можно применить к коммиту, к ветке.

**git show HEAD~~~ == git show ~3** - смещаемся на 3 коммита вниз по дереву.

Вместо HEAD можно писать @

**git show master~~:index.txt** - посмотреть версию файла index.txt в коммите который на 2 шага ниже коммита, на который указывает ветка master.

**git show :/function** - покажет самый свежий коммит в котором есть файл, содержащий слово function.

## Слияние веток перемоткой ##

**git merge branch** - слияние текущей ветки с веткой branch.

Метод слияния при этом Fast-Forward, то есть текущая ветка начинает ссылаться на тот же коммит, что и ветка branch.

Перед merge git сохраняет старый идентификатор в файл .git/ORIG_HEAD

Если нам нужно отменить результат последнего слияния, то можно ввести команду:<br>
**git branch -f master ORIG_HEAD**

## Удаление веток ##

**git branch -d fix** - удалить ветку fix, работает только если удаляемая ветка полностью совмещена с текущей, при этом коммиты остаются, удаляется ссылка fix.

**git branch -D fix** - удалит ветку несовмещенную с текущей, при этом удалится ссылка на коммит, коммиты удалённой ветки будут недостижимыми. Через некоторое время git удалит недостижимые коммиты.

## История переключений веток: лог ссылок reflog

Любые изменения при работе с ссылками git записывает в специальный файл reflog, файлы находятся в директории **.git/logs/**

**git reflog** - отображение логов в красивом виде.

**git branch feature HEAD@6** - создать ветку **feature** с ссылкой на коммит в 6 строке reflog для HEAD/

**git reflog show == git log --oneline -g**

**git reflog --date=iso** - добавление даты коммита к отображению файла reflog.

По умолчанию записи в reflog хранятся 90 дней, а недостижимые коммиты 30 дней.

gc.reflogExpire = "90 days ago"<br>
gc.reflogExpireUnreachable = "30 days ago"

reflog не отправляются вместе с коммитами при push или пересылке коллеге.

**git checkout @{-n}** - перейти на ветку n checkout-ов назад.

## Удаление "лишних" файлов и незакоммиченных изменений

**git reset --hard, git checkout -f** не будут отменять изменения в неотслеживаемых файлах.

**git clean -dxf** - -d удалить не только неотслеживаемые файлы, но и директории, -x - удалить и файлы, которые есть в .gitignore, -f - без этого не будет работать.

## Жесткий reset --hard: отмена изменений, удаление коммитов

**git reset --hard @~** - отмена последнего коммита.

Если в файлах были незакоммиченные изменения, они будут потеряны при reset.

## Мягкий reset --soft: замена и объединение коммитов

**git reset --soft @~** - перемещает HEAD на указанный коммит, при этом файлы в рабочей директории в и index не изменяются. Поэтому появятся незакомиченные изменения в этих файлах, так как их состояние не будет соответствовать коммиту на который сделан reset --soft.

То есть reset --soft по сути отменяет последний коммит, но оставляет все изменения в файлах.

**git reset --soft ORIG_HEAD** - id последнего коммита, на котором стоял HEAD хранится в файле ORIG_HEAD - переходим обратно, на удалённый коммит.

**git commit -c idCommit** - взять описание из описания коммита idCommit.<br>
* -c - откроется редактор, для редактирования сообщения
* -С - без редактирования

при этом копируется авторская дата и автор коммита.

** -- reset author** - сбросить автора из копируемого описания коммита.

## Правка последнего коммита: commit --amend

Вносим исправления в файл, который был закоммичен.

**git commit --amend == git reset --soft @~ + git commit -c ORIG_HEAD**

так же можно использовать флаг ** -- reset author** и **--no-edit** - отменяет вызов редактора.

**git commit ammend** можно использовать для редактирования текста коммита. Так как и сам коммит и его описание в git неизменяемы.

Однако ни **reset --soft**, ни **git commit --amend** не смогут изменить коммит в середине ветки, этими командами можно менять последний коммит. Если нужно поменять коммит в середине, то нужно переписать всю ветку, либо использовать команду rebase.

## Смешанный reset (без флагов), сравнение видов reset

**git reset --mixed** - он же reset по умолчанию, откатывает индекс на состояние коммита, а рабочую директорию не трогает.

У смешанного reset есть важное применение - очистка индекса **git reset HEAD**, HEAD по умолчанию.

reset - антипод команды add.

**git reset \<commit> \<filename>** - поместить в индекс **filename** из коммита **commit**.

Если нужно и заменить файл в рабочей директории, то **git checkout \<commit> \<filename>**.

В официальном руководстве **git help reset** есть таблица о действиях команды **reset** во всех возможных ситуациях.

## Сравнение коммитов, веток и не только: git diff

**git diff master feature** - сравнение изменений в двух коммитах. Коммиты можно передать например ссылкой с ветки.

В выводе формируются блоки для всех файлов, блоки состоят из hunk, которые описывают изменения в конкретных областях файлов, чтобы не печатать их целиком.

hunk имеет заголовок, который формируется по регулярных выраженим для конкретного языка программирования. Заголовок показывает, к какой секции файла относится hunk.

**git diff master..feature == git diff master feature**

**git diff master...feature** - что именно изменилось в ветке **feature** с момента её расхождения с **feature**.

**git diff \<commit1> \<commit2> feature** - сравнение двух коммитов.

**git diff \<commit>** - показывает изменения в рабочей директории, по сравнению с **\<commit>**.

**git diff HEAD** - изменения в рабочей директории, по сравнению с последним коммитом (на который указывает HEAD).

**git diff** - сравнивает рабочую директорию с index.

Все эти формы **git diff** игнорируют неотслеживаемые файлы, если новый файл добавить в index, то всё будет работать корректно.

**git diff --cashed** - то же, что и **--staged - показывает сравнение коммита и индекса. То есть покажет изменения, которые проиндексированы, но еще не в репозитории.

**git commit -v** - покажет изменения между индексом и репозиторием перед вводом сообщения коммита. Все эти данные для ознакомления, в итоговое сообщение они не войдут.

**git commit --global commit.verbose true** - включаем флаг -v по умолчанию.

**git diff \<paths>** - показать изменения в конкретном файле, или директории.

**git diff --name-only master feature** - показать только названия файлов, в которых есть изменения.

**git diff --\<paths>** - -- покажет git, что сейчас пойдет имя файла или директории, а не ветки.

**git diff commit1:path1 commit2:path2** - сравнить конкретные файлы из любых коммитов.

**git diff --no-index path1 path2** - сравнивает вообще два любых файла на диске. Diff работает изолированно от git.

## Просмотр – Диапазоны коммитов для git log и не только

**git log master** - выведет все коммиты, достижимые из master, можно указать любой коммит

**git log master feature --graph** - выведет дерево веток в виде графа.

**git log --all --graph** - выведет коммиты, достижимые из всех ссылок

**git log feature ^master** - показать все коммиты, достижимые из feature, кроме тех, которые достижимы из master.

**git log master..feature** - тоже самое, если HEAD указывает на одну из ссылок, то можно записать **git log ..feature**

Во всех этих выводах отсутствует пограничный коммит.

**git log master..feature --boundary** - показать и пограничный коммит.

**git log master...feature** - симметрическая разность, коммиты, которые не достижимы одновременно из master и feature.

**git log \<fileName\>** - показать коммиты, в которых присутствует файл \<fileName\>

**git log -p -follow \<fileName\>** - распечатает изменения в файле, причём, если он был переименован, git log выведет историю для него.

## Поиск в истории, фильтры для git log

**git log --grep Run feature** - поиск всех коммитов, где встречается слово Run. Поиск выполняется с учётом текущей ветки, т.е. во всех коммитах, которые достижимы из коммита на который указывает feature.

**git log --grep Run --grep Say** - найти слово Run **или** слово Say.

**git log --grep Run --grep Say --all-match** - найти слово Run **и** слово Say.

Поиск в общем случае происходит по регулярным выражениям. В Git используется старый стандарт RegExp.

**git log --grep 'say(Hi|Bye)' -P** - искать Perl-совместимое регулярное выражение.
<br>Либо можно настроить конфиг:
**git config --global grep.patternType perl**

**git log -F** - отключение регулярных выражений и текст в командной строке будет восприниматься как обычный.

**git log --grep Run -i** - искать без учёта регистра.

**git log -GsayHi -p** - вывести коммиты в которых были изменения, содержащие строку sayHi. Можно указать имя файла, в котором осуществляется поиск.

**git log -L 3,6:index.html** - показать все коммиты, в которых были изменения в строках с 3 по 6 в файле index.html.

**git log -L '/<head\>/','/<\/head>/':index.html** - показать все коммиты, в которых были изменения во фрагментах, заключённых в регулярные выражения. Регулярные выражения заключатся в ковычки 'RegExp'. Слэш нужно экранировать.

**git log -L :functionName:index.html** - поиск объявления функции в файле. Ищется блок с искомого названия до объявления следующей функции. Любая строка, которая начинается с буквы, _, $ - это объявление функции.<br>
Надёжнее искать по границам, задаваемым регулярными выражениями.

**git log --author=author** - искать коммиты по автору.

**git log --commiter=author** - искать коммиты по коммитеру.

**git log --before '2 months ago'** - искать коммиты по дате. **--after** - посже.

## Кто написал эту строку?

**git blame fileName** - кто написал строчку файла.

**git blame fileName --date=short -L 5,8** - дата в более коротком формате, вывести 5-8 строку.

## 7.1 Слияние – "Истинное" слияние и разрешение конфликтов в git merge

В случае, когда она ветка не является прямым потомком другой простой merge перемоткой не получится.

В этом случает Git анализирует изменения с момента, когда ветки разделились и создаёт новый коммит, в который входят изменения с обоих веток.

Перед слиянием желательно, чтобы статус был чистым. В теории допустимо, что незакомичены файлы, которые одинаковы для обоих веток.

Сначал Git ищет коммит, с которого ветки разделились.

**git merge-base master feature** - посмотреть коммит, с которого ветки разделились

Далее для каждого файла сравниваются три версии:
* base - до разделения
* ours - наша версия
* theirs - их 

base + ous + theirs = merge

Если на ветках в файлах разные изменения в одном и том же месте файла, то возникает конфликт и мы попадаем в состояние прерванного слияния.

**cat .git/MERGE_HEAD** - коммит, с которым мы осуществляем слияние.

**git diff -Un commit branch fileName** - вывести n строк, обрамляющих изменения. По умолчанию 3 строки.

При слиянии файла Git объединяет строки кода, которые изменились и не конфликтуют, конфликтные строки помечаются маркерами конфликта (текстом) и заносятся в результирующий файл в рабочей директории.

**git checkout --ours fileName** - вытащит измения из главной (нашей) ветки

**git checkout --theirs fileName** - вытащит измения из сливаемой ветки.

**git checkout --merge fileName** - версия с маркерами конфликта.

**git reset merge** - оставит незакомиченные изменения в файлах, которые не конфликтуют. Это бывает необходимо, если в рабочей директории есть изменения, которые отсутствуют в индексе, и мы хотим чтобы они пережили слияние и его отмену. В отличии от **reset --hard**, который отменит все изменения.

**git merge --abort** - тоже, что и **git reset merge**

**git checkout --conflict=diff3 --merge fileName** - в файл слияния добавятся не только маркеры конфликта, но и состояние строчки в файле в коммите, когда ветки разделились.

**git config --global merge.conflictStyle diff3** - установить в конфиге использовать добавление базовой строки и двух сливаемых.

После того как в файл были внесены правильные изменения нельзя сразу сделать коммит. Так как в индексе хранятся три версии файла: базовая и две сливаемые.

* git show :1:fileName - базовая версия
* git show :2:fileName - наша версия
* git show :3:fileName - сливаемая версия

При этом многие команды Git работают не так как обычно, либо не работают вообще.

Итак после того, как файл сформирован добавляем его в индекс (git add fileName).

**git merge --continue** - псевдоним для **git commit** работает только из состояния слияиния.

## 7.2 Слияние – Коммит слияния, дальнейшие слияния

После слияния создаётся специальный коммит слияния, его главное отличие в том, что у него два родителя.

Обычно при создании коммита в него записывает идентификатор коммита, который был до него (old HEAD). В начале слияния команда merge создает в директории .git файл MERGE_HEAD который содержит идентификатор вершины ветки с которой мы сливаем. Команда commit учитывает наличие этого файла и добавляет эту информацию как дополнительный родитель.

**git log --oneline --all --graph** - обоих родителей можно увидеть на графе структуры.

**git show** - покажет коммит на который указвает HEAD, в нём будет строка Merge и идентификаторы родительских коммитов. Diff при этом будет сжатый (combined condensed diff). В нём показывается различие базового файла от двух других.

Знак плюса на позиции слева показывает, что этой строчки не было в выбранной ветке, а справа - не было в сливаемом файле. Оба плюса могут быть, если строчка была добавлена вручную при разрешении конфликта слияния.

Знак "минус", если строки удалены соответственно.

Diff сжатый, потому что показываются только те строчки, в которых были конфликты.

**git show --first-parent** - отличия от первого родителя.

**git show -m** - отличия от всех родителей.

Но проще различия смотреть с помощью diff:

**git diff HEAD^1** - отличия от первого родителя (HEAD^2 - от второго).

HEAD^^ - первый родитель первого родителя.

HEAD^ == HEAD~

~ - переход по первому родителя N количество раз, ^ нужна только для работы с коммитами слияиния.

Для чего нужны коммиты слияиния?

* В истории разработки отображается, что коммит получен из двух предыдущих
* если еще раз запустить слияние, то ничего не произойдет так как Git знает что слияние уже совершено. Так как одна ветка будет потомком другой и в сливаемой ветке нет новых коммитов - значит делать ничего не надо.

**git branch --merged** - покажет ветки объединенные с текущей.

**git branch --no-merged** - ветки необъединенные с текущей.

**git merge branch -m "Commit"** - добавить текст описания коммита слияния.

**git merge branch --log** - добавить текст описаний всех сливаемых коммитов с ветки theirs. Здесь же можно задать верхний лиммит (по умолчанию не больше 20).

**git log master --oneline --first-parent** - посмотреть историю разработки ветки master, отсекая коммиты на сливаемых ветках.

Git log если видит коммит слияиния идет только по первому родителю.

## 7.3 Git – Слияние – Отмена слияния

Отменить коммит слияиния можно **git reset --hard @~**, несмотря на то, что у него два родителя, он находится только на одной ветке.

С добавлением и удалением строк надо быть осторожным и выполнять только действия для разрешения конфликта.

Отмена коммита слияния, создание нового коммита являются обратимыми. Если не прошло много времени, то отмененные коммиты всё ещё присутствуют в базе.

**git reflog -4** - посмотреть 4 последние записи.

**git reset --hard commit** - вернуться на удалённый коммит.

## 7.4 Git – Слияние – Семантические конфликты и их разрешение

Иногда в процессе слияния на одной ветке вносятся изменения в семантическую(смысловую) часть кода, которые не внесены в другой ветке. И хотя слияние проходит успешно, так как контролируется только содержание строк, но в целом результируюций файл получается с смысловой ошибкой.

Чтобы избежать этого можно выполнить слияние без коммита:<br>
**git merge branch --no-commit** - файл в рабочей директории будет обновлён и добавлен в индекс, но коммит не производится.

Мы находимся в состоянии прерванного слияния и содержится файл .git/MERGE_HEAD с идентификатором сливаемого коммита. Благодаря этому Git знает, что мы находимся в процесси слияния.

Решаем семантический конфликт. Добавляем последнее изменение в индекс **git add fileName** и теперь завершаем слияние git merge --continue (или git commit). Благодаря наличию файла MERGE_HEAD Git создаст именно коммит слияния.










































